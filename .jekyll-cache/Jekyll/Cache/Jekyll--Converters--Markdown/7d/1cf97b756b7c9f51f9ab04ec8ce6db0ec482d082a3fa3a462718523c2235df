I"#<h3 id="一位的意思">一.位的意思</h3>
<ul>
  <li>计算机中的位
    <ul>
      <li>二进制数(binary number)用两个数做基础，其中每一个二进制数字(称为位，bit)不是0就是1.</li>
      <li>位自右向左，从0开始顺序增量编号，一个8位的二进制数表示为:</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>假如具体的数字为2的话，就为</p>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>计算的结果是：2^1=2</p>

<p>具体的数字为3的话，就为</p>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>计算的结果为: 2^0 + 2^1 = 3</p>

<ul>
  <li><kbd>int8</kbd>，<kbd>int16</kbd>，<kbd>int32</kbd>，<kbd>int64</kbd>就分别表示为8位的整数，16位的整数，32位的整数，64位的整数.</li>
</ul>

<h3 id="二理解位的运算">二.理解位的运算</h3>
<p>假如X为2，Y为4，对应位的显示就为:<br />
X:</p>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Y:</p>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<h5 id="1按位与">1.按位与</h5>
<ul>
  <li>描述：相同位的两个数字都为1，则为1，否则为0，C语言中是<kbd>X&amp;Y</kbd>，得出的结果为：</li>
</ul>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>计算结果为：0(看到X第1位为1，Y第1位为0，所以算出的结果第1位为0，同理得算出的结果的第2位为0)</p>

<h5 id="2按位或">2.按位或</h5>
<ul>
  <li>描述：相同位只要有一个为1，则为1，否则为0，C语言中为<kbd>X|Y</kbd>，得出的结果为：</li>
</ul>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>算出的结果为：2^1+2^2 = 6 (X第1位为1，Y第1位为0，所以“或”之后得到结果第1位为1，同理第2位也为1)</p>

<h5 id="3按位异或">3.按位异或</h5>
<ul>
  <li>描述：相同位不同则为1，相同则为0，C语言中为<kbd>X^Y</kbd>，得出的结果为：</li>
</ul>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>计算结果为：2^1+2^2 = 6 (X第1位为1，Y第1位为0，“异或”之后的结果第1位为1，同理第2位也为1，其他为0)</p>

<h5 id="4按位取反">4.按位取反</h5>
<ul>
  <li>描述：对原位的0和1全部取反(要考虑有没有符号)，C语言中为<kbd>~X</kbd>，得出的结果为：</li>
</ul>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>计算结果为：2^0+2^2+2^3+2^4+2^5+2^6+2^7 (不想算结果了，X中第1位为1，其他为0，所以取反后就是这个结果)</p>

<h5 id="5左移">5.左移</h5>
<ul>
  <li>描述：X的位左移a位，相当于X*2^a，C语言中是<kbd>X&lt;&lt;a</kbd>，假如a是2，得出的结果是：</li>
</ul>

<table>
  <thead>
    <tr>
      <th>下标</th>
      <th>7</th>
      <th>6</th>
      <th>5</th>
      <th>4</th>
      <th>3</th>
      <th>2</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对应位</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>计算结果为：2^3 = 8 (X中的位都左移2位，相当于2*2^2 = 8)</p>

<h5 id="6右移">6.右移</h5>
<ul>
  <li>描述：X的位右移a位，相当于X/2^a(取整)，C语言中是<kbd>X&gt;&gt;a</kbd>，结算的过程跟左移差不多，但是是右移的，就不算了.</li>
</ul>

<h3 id="三lua的bit库">三.Lua的bit库</h3>
<blockquote>
  <p>lua的原生库中有对位运算的函数.</p>
</blockquote>

<ul>
  <li>bit.band   “与”操作  X和Y都为1时则为1，否则为0</li>
  <li>bit.rol   “左旋”</li>
  <li>bit.rshift   “逻辑右移”</li>
  <li>bit.lshift   “逻辑左移”</li>
  <li>bit.ror   “右旋”</li>
  <li>bit.bxor   “非”操作  X和Y不同则为1，否则为0</li>
  <li>bit.bor   “或”操作  X和Y中有一个为1，则为1，否则为0</li>
  <li>bit.arshift   “算术”右移</li>
  <li>bit.bnot   “取反”操作</li>
  <li>tobit   转成位格式</li>
  <li>tohex   转出16进制格式</li>
</ul>

<h3 id="四lua的bit实践">四.lua的bit实践</h3>
<ul>
  <li>红点位记录
    <ul>
      <li>
        <p>问题描述：一个模块有一个总的红点显示，这个红点受其模块下的标签红点影响，比如模块A的有三个标签1、2、3，只要其中一个标签有红点，则模块A就会有红点.</p>
      </li>
      <li>实现：初始化总红点<kbd>all_red = 0</kbd>，各个标签设为1，2，3，那么单个标签(假设标签为tab)设置红点的接口：
        <ul>
          <li>有红点时：<kbd>bit.bor(all_red, bit.lshift(1, tab))</kbd>，再把最后的值给<kbd>all_red</kbd>；</li>
          <li>无红点时：<kbd>bit.band(all_red, bit.bnot(bit.lshift(1, tab)))</kbd>，再把最后的值给<kbd>all_red</kbd>；</li>
        </ul>
      </li>
      <li>使用：最后使用就是用于判断主模块红点以及各个标签的红点:
        <ul>
          <li>判断主模块的红点：<kbd>all_red &gt; 0</kbd>是否为true，为true则是有红点；</li>
          <li>判断各个标签的红点：<kbd>bit.band(all_red, bit.lshift(1, tab)) ~= 0</kbd>是否为true，为true则是单个标签有红点；</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="五链接">五.链接</h3>
<p><a href="https://baike.baidu.com/item/%E4%BD%8D%E8%BF%90%E7%AE%97/6888804?fr=aladdin">https://baike.baidu.com/item/%E4%BD%8D%E8%BF%90%E7%AE%97/6888804?fr=aladdin</a><br />
  <a href="http://c.biancheng.net/view/3299.html">http://c.biancheng.net/view/3299.html</a></p>
:ET